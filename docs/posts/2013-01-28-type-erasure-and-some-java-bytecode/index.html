<p>If you've worked with Java for a while, I'm sure you've heard about one of the things that Java does at compile time: type erasure. But you don't have to trust everybody by their word, you can check it by yourself!</p><p>As you know, when you &quot;compile&quot; your class, the .java file is transformed into a .class file, which is a binary file containing JVM operation codes (each operation is represented by a byte = bytecode). This .class file is interpreted by the JVM and later compiled into machine code at runtime by the Just In Time compiler.</p><p>A good way to see how Java treats internally all this <a href="http://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="noopener noreferrer">&quot;syntactic sugar&quot;</a> is to have a look at the bytecode. Fortunately, Java provides a tool for this, so you don't have to crack your skull with a HEX viewer: the <em>javap</em> tool the JDK comes with.</p><h3 id="a_simple_class" tabindex="-1">A simple class</h3><a class="direct-link" href="#a_simple_class"><span class="visually-hidden">Permalink to “A simple class”</span> <span aria-hidden="true"></span></a><p>Let's take the following simple class as our lab rat (no animals were hurt in this experiment):</p><p>And compile it (I use JDK 1.7.0_03) to get ASimpleClass.class file.</p><h3 id="javap_magic" tabindex="-1">javap magic</h3><a class="direct-link" href="#javap_magic"><span class="visually-hidden">Permalink to “javap magic”</span> <span aria-hidden="true"></span></a><p>We're gonna use the javap tool to get two things: one, the constant pool and second, the class disassembled. I will not start explaining most of the things found in the following output because this would end up in huge article (yes, they can get even bigger). You can find out more by yourself by visiting the <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener noreferrer">opcode reference</a> from Oracle.</p><p>So, go on and run <code>javap -v ASimpleClass.class</code> and don't freak out when you see something like the output from this link: <a href="https://gist.github.com/4648077" target="_blank" rel="noopener noreferrer">ASimpleClass.class</a></p><p>The constant pool contains elements which are constant inside the class. The disassembled class opcode contains references to the constant pool for almost every operation. But you don't have to rush and see what the reference is, because javap puts it as a comment on the right side of the operation call.</p><h3 id="java_disassembled_code" tabindex="-1">Java disassembled code</h3><a class="direct-link" href="#java_disassembled_code"><span class="visually-hidden">Permalink to “Java disassembled code”</span> <span aria-hidden="true"></span></a><p>Let's focus a bit on the main method disassembled:</p><p>The first 3 lines are encountered each time we create a new instance of a class:</p><pre><code>&lt;code&gt;0: new           #2                  // class java/util/ArrayList
3: dup           
4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V
&lt;/code&gt;
</code></pre><p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.new" target="_blank" rel="noopener noreferrer">new</a> allocates memory for the new instance, initializes instance variables and pushes the new reference in the operand stack, <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.dup" target="_blank" rel="noopener noreferrer">dup</a> duplicates the top value on the operand stack and pushes the duplicate onto the operand stack and finally <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokespecial" target="_blank" rel="noopener noreferrer">invokespecial</a> calls the method referenced at line #3 in the constant pool, in our case the <em>ArrayList</em> constructor.</p><p>I guess you started to get the hang of it, you might not understand everything but the gist should be there.</p><h3 id="type_erasure" tabindex="-1">Type erasure</h3><a class="direct-link" href="#type_erasure"><span class="visually-hidden">Permalink to “Type erasure”</span> <span aria-hidden="true"></span></a><p>You might have noticed already that the <em>ArrayList</em> reference doesn't have any generic and its <em>add</em> method receives an <em>Object</em> and not a String, as you can notice in the constant pool <em>NameAndType</em> entry at line #48:</p><pre><code>&lt;code&gt;#48 = NameAndType        #67:#68        //  add:(Ljava/lang/Object;)Z
&lt;/code&gt;
</code></pre><p>But this doesn't mean that when the <em>Object</em> instances are pulled out by the iterator, the JVM doesn't check its type to be <em>String</em>:</p><pre><code>&lt;code&gt;43: invokeinterface #9,  1            // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;
48: checkcast     #10                 // class java/lang/String
&lt;/code&gt;
</code></pre><p>invokeinterface calls the next() method and puts the result in the operand stack, which is checked afterwards by <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.checkcast" target="_blank" rel="noopener noreferrer">checkcast</a> to be a <em>String</em>.</p><h3 id="other_notes" tabindex="-1">Other notes</h3><a class="direct-link" href="#other_notes"><span class="visually-hidden">Permalink to “Other notes”</span> <span aria-hidden="true"></span></a><p>It would be interesting to have a look at how the <em>for</em> statement was treated (starting #27) and how the concatenation of the two _String_s (&quot;Type&quot; and &quot;erasure&quot;) was made (#55:#71), but I don't want to spoil your geek fun and leave you to it!</p>